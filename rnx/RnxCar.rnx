{-# LANGUAGE OverloadedStrings #-}

module Main where

import qualified Graphics.UI.Gtk as Gtk
import Graphics.UI.Gtk (set, on, AttrOp((:=)))
import qualified Graphics.Rendering.Cairo as Cairo
import Data.IORef
import Control.Monad (void, when)
import Control.Monad.IO.Class (liftIO)
import Data.Text (Text, pack)

-- = Game Logic =

-- Car state
data CarState = CarState
  { carAngle :: Double      -- Angle on circular track (radians)
  , carSpeed :: Double      -- Current speed
  , carMaxSpeed :: Double   -- Maximum speed
  , carAcceleration :: Double -- Acceleration rate
  , carDeceleration :: Double -- Deceleration rate
  , carTurningSpeed :: Double -- Turning speed
  } deriving (Show)

-- Game state
data GameState = GameState
  { car :: CarState
  , trackRadius :: Double
  , centerX :: Double
  , centerY :: Double
  , gamePaused :: Bool
  } deriving (Show)

-- Initial game state
initialGameState :: GameState
initialGameState = GameState
  { car = CarState
      { carAngle = 0
      , carSpeed = 0
      , carMaxSpeed = 0.1
      , carAcceleration = 0.005
      , carDeceleration = 0.01
      , carTurningSpeed = 0.03
      }
  , trackRadius = 150
  , centerX = 200
  , centerY = 200
  , gamePaused = False
  }

-- Update car position based on speed
updateCarPosition :: CarState -> CarState
updateCarPosition carState = carState { carAngle = newAngle }
  where
    currentAngle = carAngle carState
    speed = carSpeed carState
    newAngle = currentAngle + speed
    -- Keep angle within [0, 2π]
    normalizedAngle = if newAngle >= 2 * pi then newAngle - 2 * pi else newAngle

-- Apply acceleration
accelerate :: CarState -> CarState
accelerate carState = carState { carSpeed = min (carMaxSpeed carState) newSpeed }
  where
    currentSpeed = carSpeed carState
    acceleration = carAcceleration carState
    newSpeed = currentSpeed + acceleration

-- Apply deceleration/braking
decelerate :: CarState -> CarState
decelerate carState = carState { carSpeed = max 0 newSpeed }
  where
    currentSpeed = carSpeed carState
    decel = carDeceleration carState
    newSpeed = currentSpeed - decel

-- Turn left (counter-clockwise)
turnLeft :: CarState -> CarState
turnLeft carState = carState { carAngle = newAngle }
  where
    currentAngle = carAngle carState
    turningSpeed = carTurningSpeed carState
    newAngle = if currentAngle - turningSpeed < 0 
               then 2 * pi - turningSpeed 
               else currentAngle - turningSpeed

-- Turn right (clockwise)
turnRight :: CarState -> CarState
turnRight carState = carState { carAngle = newAngle }
  where
    currentAngle = carAngle carState
    turningSpeed = carTurningSpeed carState
    newAngle = if currentAngle + turningSpeed >= 2 * pi 
               then turningSpeed 
               else currentAngle + turningSpeed

-- Apply friction when no input
applyFriction :: CarState -> CarState
applyFriction carState
  | currentSpeed > 0 = carState { carSpeed = max 0 (currentSpeed - friction) }
  | otherwise = carState
  where
    currentSpeed = carSpeed carState
    friction = 0.002

-- Update game state
updateGame :: GameState -> GameState
updateGame state
  | gamePaused state = state
  | otherwise = state { car = newCarState }
  where
    currentCar = car state
    newCarState = applyFriction $ updateCarPosition currentCar

-- Calculate car position on track
getCarPosition :: GameState -> (Double, Double)
getCarPosition state = (x, y)
  where
    radius = trackRadius state
    angle = carAngle (car state)
    x = centerX state + radius * cos angle
    y = centerY state + radius * sin angle

-- Calculate car direction vector
getCarDirection :: GameState -> (Double, Double)
getCarDirection state = (dx, dy)
  where
    angle = carAngle (car state)
    -- Car faces tangent to the circle (90 degrees offset)
    dx = -sin angle
    dy = cos angle

-- = GTK Interface =

createWindow :: IORef GameState -> IO ()
createWindow gameStateRef = do
  Gtk.initGUI
  
  -- Create main window [citation:1][citation:9]
  window <- Gtk.windowNew
  Gtk.set window 
    [ Gtk.windowTitle := (pack "Круговая трасса - Haskell/GTK+3")
    , Gtk.containerBorderWidth := 10
    , Gtk.windowDefaultWidth := 500
    , Gtk.windowDefaultHeight := 500
    , Gtk.windowResizable := False
    ]
  
  -- Main vertical container
  mainBox <- Gtk.vBoxNew False 10
  Gtk.containerAdd window mainBox
  
  -- Info label
  infoLabel <- Gtk.labelNew (Just (pack "Скорость: 0.00 | Угол: 0.00"))
  Gtk.boxPackStart mainBox infoLabel Gtk.PackNatural 0
  
  -- Drawing area for the game
  drawingArea <- Gtk.drawingAreaNew
  Gtk.widgetSetSizeRequest drawingArea 400 400
  Gtk.boxPackStart mainBox drawingArea Gtk.PackGrow 0
  
  -- Status label
  statusLabel <- Gtk.labelNew (Just (pack "Управление: Стрелки - движение, P - пауза, R - сброс"))
  Gtk.boxPackStart mainBox statusLabel Gtk.PackNatural 0
  
  -- Button container
  buttonBox <- Gtk.hBoxNew True 10
  Gtk.boxPackStart mainBox buttonBox Gtk.PackNatural 0
  
  -- Reset button
  resetButton <- Gtk.buttonNewWithLabel (pack "Сброс")
  Gtk.boxPackStart buttonBox resetButton Gtk.PackGrow 0
  
  -- Pause button
  pauseButton <- Gtk.buttonNewWithLabel (pack "Пауза")
  Gtk.boxPackStart buttonBox pauseButton Gtk.PackGrow 0

  -- Drawing handler using Cairo [citation:3]
  Gtk.on drawingArea Gtk.draw $ do
    state <- liftIO $ readIORef gameStateRef
    
    -- Set white background
    Cairo.setSourceRGB 1 1 1
    Cairo.paint
    
    -- Draw track
    drawTrack state
    
    -- Draw car
    drawCar state
    

  -- Function to update UI
  let updateUI = do
        state <- readIORef gameStateRef
        let currentCar = car state
        let speed = carSpeed currentCar
        let angle = carAngle currentCar
        
        Gtk.set infoLabel [Gtk.labelLabel := pack (
          "Скорость: " ++ show (fromIntegral (round (speed * 1000)) / 1000.0 :: Double) ++ 
          " | Угол: " ++ show (fromIntegral (round (angle * 1000)) / 1000.0 :: Double) ++ " рад.")]

        let statusMsg = if gamePaused state 
              then "ПАУЗА - Управление: Стрелки - движение, P - пауза, R - сброс"
              else "Игра идет... Управление: Стрелки - движение, P - пауза, R - сброс"
        
        Gtk.set statusLabel [Gtk.labelLabel := pack statusMsg]
        Gtk.widgetQueueDraw drawingArea 

  -- Handle keyboard input [citation:7]
  Gtk.on window Gtk.keyPressEvent $ do
    keyVal <- Gtk.eventKeyVal
    state <- liftIO $ readIORef gameStateRef
    let currentCar = car state
    
    case keyVal of
      -- Up arrow - accelerate
      65362 -> do
        liftIO $ do
          modifyIORef gameStateRef (\s -> 
            s { car = accelerate (car s) })
          updateUI
        return True
      
      -- Down arrow - decelerate
      65364 -> do
        liftIO $ do
          modifyIORef gameStateRef (\s -> 
            s { car = decelerate (car s) })
          updateUI
        return True
      
      -- Left arrow - turn left
      65361 -> do
        liftIO $ do
          modifyIORef gameStateRef (\s -> 
            s { car = turnLeft (car s) })
          updateUI
        return True
      
      -- Right arrow - turn right
      65363 -> do
        liftIO $ do
          modifyIORef gameStateRef (\s -> 
            s { car = turnRight (car s) })
          updateUI
        return True
      
      -- 'P' key - pause
      112 -> do
        liftIO $ do
          modifyIORef gameStateRef (\s -> s { gamePaused = not (gamePaused s) })
          updateUI
        return True
      
      -- 'R' key - reset
      114 -> do
        liftIO $ do
          writeIORef gameStateRef initialGameState
          updateUI
        return True
      
      _ -> return False

  -- Reset button handler
  Gtk.on resetButton Gtk.buttonActivated $ do
    writeIORef gameStateRef initialGameState
    updateUI

  -- Pause button handler
  Gtk.on pauseButton Gtk.buttonActivated $ do
    modifyIORef gameStateRef (\s -> s { gamePaused = not (gamePaused s) })
    updateUI

  -- Game loop (update every 30ms) [citation:5]
  let gameLoop :: IO Bool
      gameLoop = do
        state <- readIORef gameStateRef
        let newState = updateGame state
        writeIORef gameStateRef newState
        updateUI
        return True  -- Continue looping
  
  -- Start game loop
  void $ Gtk.timeoutAdd gameLoop 30

  -- Handle window close
  Gtk.on window Gtk.objectDestroy Gtk.mainQuit

  -- Show window and start main loop
  Gtk.widgetShowAll window
  Gtk.mainGUI

-- Draw the circular track
drawTrack :: GameState -> Cairo.Render ()
drawTrack state = do
  -- Draw outer track boundary
  Cairo.setSourceRGB 0.3 0.3 0.3
  Cairo.setLineWidth 5
  Cairo.arc (centerX state) (centerY state) (trackRadius state + 20) 0 (2 * pi)
  Cairo.stroke
  
  -- Draw inner track boundary
  Cairo.arc (centerX state) (centerY state) (trackRadius state - 20) 0 (2 * pi)
  Cairo.stroke
  
  -- Draw track surface
  Cairo.setSourceRGB 0.8 0.8 0.8
  Cairo.arc (centerX state) (centerY state) (trackRadius state) 0 (2 * pi)
  Cairo.fill
  
  -- Draw center point
  Cairo.setSourceRGB 0.5 0.5 0.5
  Cairo.arc (centerX state) (centerY state) 5 0 (2 * pi)
  Cairo.fill

-- Draw the car
drawCar :: GameState -> Cairo.Render ()
drawCar state = do
  let (carX, carY) = getCarPosition state
  let (dirX, dirY) = getCarDirection state
  let currentSpeed = carSpeed (car state)
  
  -- Save current transformation
  Cairo.save
  
  -- Move to car position and rotate according to direction
  Cairo.translate carX carY
  Cairo.rotate (carAngle (car state) + pi/2)  -- +pi/2 to make car face forward
  
  -- Car color based on speed (red when fast, blue when slow)
  let speedRatio = currentSpeed / carMaxSpeed (car state)
  let red = 0.5 + speedRatio * 0.5
  let green = 0.3
  let blue = 0.7 - speedRatio * 0.5
  
  Cairo.setSourceRGB red green blue
  
  -- Draw car body (rectangle)
  let carLength = 30
  let carWidth = 15
  Cairo.rectangle (-carWidth/2) (-carLength/2) carWidth carLength
  Cairo.fill
  
  -- Draw car details
  Cairo.setSourceRGB 0.1 0.1 0.1
  Cairo.setLineWidth 2
  
  -- Windshield
  Cairo.rectangle (-carWidth/2 + 2) (-carLength/2 + 5) (carWidth - 4) 8
  Cairo.stroke
  
  -- Windows
  Cairo.moveTo 0 (-carLength/2 + 13)
  Cairo.lineTo 0 (carLength/2 - 5)
  Cairo.stroke
  
  -- Restore transformation
  Cairo.restore

-- Main function
main :: IO ()
main = do
  let initialState = initialGameState
  gameStateRef <- newIORef initialState
  createWindow gameStateRef