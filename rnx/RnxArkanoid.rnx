{-# LANGUAGE OverloadedStrings #-}

module Main where

import qualified Graphics.UI.Gtk as Gtk
import Graphics.UI.Gtk (set, on, AttrOp((:=)))
import qualified Graphics.Rendering.Cairo as Cairo
import Data.IORef
import Control.Monad (void, when)
import Control.Monad.IO.Class (liftIO)
import Data.Text (Text, pack)
import System.Random (randomRIO)

-- = Логика игры "Арканоид" =

-- Направление движения мяча
data Direction = DirUpLeft | DirUpRight | DirDownLeft | DirDownRight deriving (Eq, Show)

-- Позиция на игровом поле
type Position = (Double, Double)

-- Размеры объектов
type Size = (Double, Double)

-- Состояние игры
data GameState = GameState
  { paddle :: Position      -- Позиция платформы (x, y)
  , ball :: Position        -- Позиция мяча (x, y)
  , ballDirection :: Direction
  , blocks :: [Position]    -- Позиции блоков (x, y)
  , gameOver :: Bool
  , gamePaused :: Bool
  , score :: Int
  , lives :: Int
  } deriving (Show)

-- Размеры игрового поля
fieldWidth :: Double
fieldWidth = 400

fieldHeight :: Double
fieldHeight = 500

-- Размеры объектов
paddleWidth :: Double
paddleWidth = 60

paddleHeight :: Double
paddleHeight = 10

ballSize :: Double
ballSize = 10

blockWidth :: Double
blockWidth = 40

blockHeight :: Double
blockHeight = 20

-- Скорость движения
ballSpeed :: Double
ballSpeed = 3

paddleSpeed :: Double
paddleSpeed = 8

-- Начальное состояние игры
initialGameState :: IO GameState
initialGameState = do
  let startPaddle = (fieldWidth / 2 - paddleWidth / 2, fieldHeight - 30)
      startBall = (fieldWidth / 2 - ballSize / 2, fieldHeight - 50)
      startBlocks = generateBlocks
  return $ GameState
    { paddle = startPaddle
    , ball = startBall
    , ballDirection = DirUpLeft
    , blocks = startBlocks
    , gameOver = False
    , gamePaused = True
    , score = 0
    , lives = 3
    }

-- Генерация блоков
generateBlocks :: [Position]
generateBlocks =
  [ (x, y)
  | row <- [0..4]
  , col <- [0..8]
  , let x = fromIntegral col * (blockWidth + 5) + 20
  , let y = fromIntegral row * (blockHeight + 5) + 50
  ]

-- Проверка столкновения двух прямоугольников
checkCollision :: Position -> Size -> Position -> Size -> Bool
checkCollision (x1, y1) (w1, h1) (x2, y2) (w2, h2) =
  x1 < x2 + w2 &&
  x1 + w1 > x2 &&
  y1 < y2 + h2 &&
  y1 + h1 > y2

-- Обновление состояния игры
updateGame :: GameState -> IO GameState
updateGame state
  | gameOver state || gamePaused state = return state
  | otherwise = do
    let (ballX, ballY) = ball state
        (paddleX, paddleY) = paddle state
        
        -- Движение мяча
        (newBallX, newBallY, newDir) = moveBall ballX ballY (ballDirection state)
        
        -- Проверка столкновения со стенами
        (finalBallX, finalBallY, finalDir) = checkWallCollision newBallX newBallY newDir
        
        -- Проверка столкновения с платформой
        (ballAfterPaddle, dirAfterPaddle) = checkPaddleCollision finalBallX finalBallY finalDir paddleX paddleY
        
        -- Проверка столкновения с блоками
        (ballAfterBlocks, dirAfterBlocks, newBlocks, scoreIncrease) = 
          checkBlockCollisions ballAfterPaddle dirAfterPaddle (blocks state)
        
        -- Проверка проигрыша (мяч упал вниз)
        (gameOver', lives') = if snd ballAfterBlocks > fieldHeight
          then if lives state <= 1
            then (True, 0)
            else (False, lives state - 1)
          else (gameOver state, lives state)
        
        -- Проверка выигрыша (все блоки разрушены)
        allBlocksDestroyed = null newBlocks
        
        finalGameOver = gameOver' || allBlocksDestroyed
        
        newScore = score state + scoreIncrease
        
    return $ state
      { ball = ballAfterBlocks
      , ballDirection = dirAfterBlocks
      , blocks = newBlocks
      , gameOver = finalGameOver
      , score = newScore
      , lives = lives'
      }

-- Движение мяча
moveBall :: Double -> Double -> Direction -> (Double, Double, Direction)
moveBall x y dir =
  case dir of
    DirUpLeft    -> (x - ballSpeed, y - ballSpeed, DirUpLeft)
    DirUpRight   -> (x + ballSpeed, y - ballSpeed, DirUpRight)
    DirDownLeft  -> (x - ballSpeed, y + ballSpeed, DirDownLeft)
    DirDownRight -> (x + ballSpeed, y + ballSpeed, DirDownRight)

-- Проверка столкновения со стенами
checkWallCollision :: Double -> Double -> Direction -> (Double, Double, Direction)
checkWallCollision x y dir
  | x <= 0 = (0, y, bounceX dir)
  | x + ballSize >= fieldWidth = (fieldWidth - ballSize, y, bounceX dir)
  | y <= 0 = (x, 0, bounceY dir)
  | otherwise = (x, y, dir)

-- Отскок от вертикальной поверхности
bounceX :: Direction -> Direction
bounceX DirUpLeft = DirUpRight
bounceX DirUpRight = DirUpLeft
bounceX DirDownLeft = DirDownRight
bounceX DirDownRight = DirDownLeft

-- Отскок от горизонтальной поверхности
bounceY :: Direction -> Direction
bounceY DirUpLeft = DirDownLeft
bounceY DirUpRight = DirDownRight
bounceY DirDownLeft = DirUpLeft
bounceY DirDownRight = DirUpRight

-- Проверка столкновения с платформой
checkPaddleCollision :: Double -> Double -> Direction -> Double -> Double -> ((Double, Double), Direction)
checkPaddleCollision ballX ballY dir paddleX paddleY =
  if checkCollision (ballX, ballY) (ballSize, ballSize) (paddleX, paddleY) (paddleWidth, paddleHeight)
  then ((ballX, paddleY - ballSize), bounceY dir)
  else ((ballX, ballY), dir)

-- Проверка столкновений с блоками
checkBlockCollisions :: (Double, Double) -> Direction -> [Position] -> ((Double, Double), Direction, [Position], Int)
checkBlockCollisions ballPos dir blocks =
  foldl checkSingleBlock (ballPos, dir, blocks, 0) blocks
  where
    checkSingleBlock (currentBall, currentDir, currentBlocks, currentScore) block =
      if checkCollision currentBall (ballSize, ballSize) block (blockWidth, blockHeight)
      then
        let (newBallX, newBallY) = currentBall
            (blockX, blockY) = block
            
            -- Определяем сторону столкновения для правильного отскока
            collisionFromTop = abs (newBallY + ballSize - blockY) < 5
            collisionFromBottom = abs (newBallY - (blockY + blockHeight)) < 5
            collisionFromLeft = abs (newBallX + ballSize - blockX) < 5
            collisionFromRight = abs (newBallX - (blockX + blockWidth)) < 5
            
            newDir
              | collisionFromTop || collisionFromBottom = bounceY currentDir
              | collisionFromLeft || collisionFromRight = bounceX currentDir
              | otherwise = bounceY currentDir  -- По умолчанию отскакиваем вверх/вниз
            
            remainingBlocks = filter (/= block) currentBlocks
            scoreIncrease = 10
        in (currentBall, newDir, remainingBlocks, currentScore + scoreIncrease)
      else
        (currentBall, currentDir, currentBlocks, currentScore)

-- Движение платформы
movePaddle :: GameState -> Double -> GameState
movePaddle state delta
  | gameOver state = state
  | otherwise =
    let (x, y) = paddle state
        newX = max 0 (min (fieldWidth - paddleWidth) (x + delta))
    in state { paddle = (newX, y) }

-- = Графический интерфейс GTK =

-- Создание главного окна
createWindow :: IORef GameState -> IO ()
createWindow gameStateRef = do
  Gtk.initGUI
  
  -- Создание главного окна
  window <- Gtk.windowNew
  Gtk.set window 
    [ Gtk.windowTitle := (pack "Арканоид - Haskell/GTK+3")
    , Gtk.containerBorderWidth := 10
    , Gtk.windowDefaultWidth := floor fieldWidth + 50
    , Gtk.windowDefaultHeight := floor fieldHeight + 100
    ]
  
  -- Главный вертикальный контейнер
  mainBox <- Gtk.vBoxNew False 10
  Gtk.containerAdd window mainBox
  
  -- Метка для отображения счета и жизней
  infoLabel <- Gtk.labelNew (Just (pack "Счет: 0 | Жизни: 3"))
  Gtk.boxPackStart mainBox infoLabel Gtk.PackNatural 0
  
  -- Область для рисования игры
  drawingArea <- Gtk.drawingAreaNew
  Gtk.widgetSetSizeRequest drawingArea (floor fieldWidth) (floor fieldHeight)
  Gtk.boxPackStart mainBox drawingArea Gtk.PackGrow 0
  
  -- Метка для отображения статуса игры
  statusLabel <- Gtk.labelNew (Just (pack "Игра началась! Управление: стрелки влево/вправо, P - пауза"))
  Gtk.boxPackStart mainBox statusLabel Gtk.PackNatural 0
  
  -- Горизонтальный контейнер для кнопок
  buttonBox <- Gtk.hBoxNew True 10
  Gtk.boxPackStart mainBox buttonBox Gtk.PackNatural 0
  
  -- Кнопка для перезапуска игры
  restartButton <- Gtk.buttonNewWithLabel (pack "Новая игра")
  Gtk.boxPackStart buttonBox restartButton Gtk.PackGrow 0
  
  -- Кнопка паузы
  pauseButton <- Gtk.buttonNewWithLabel (pack "Пауза")
  Gtk.boxPackStart buttonBox pauseButton Gtk.PackGrow 0
  
  -- Обработчик отрисовки с использованием Cairo
  Gtk.on drawingArea Gtk.draw $ do
    state <- liftIO $ readIORef gameStateRef
    
    -- Устанавливаем черный фон
    Cairo.setSourceRGB 0 0 0
    Cairo.paint
    
    -- Рисуем платформу (синяя)
    let (paddleX, paddleY) = paddle state
    Cairo.setSourceRGB 0 0 1
    Cairo.rectangle paddleX paddleY paddleWidth paddleHeight
    Cairo.fill
    
    -- Рисуем мяч (белый)
    let (ballX, ballY) = ball state
    Cairo.setSourceRGB 1 1 1
    Cairo.rectangle ballX ballY ballSize ballSize
    Cairo.fill
    
    -- Рисуем блоки (разные цвета в зависимости от ряда)
    mapM_ (drawBlock (blocks state)) [0..4]
  
  -- Функция для рисования блока
  let drawBlock blocks row = do
        let rowBlocks = filter (\(_, y) -> 
              y >= fromIntegral (50 + row * 25) && 
              y < fromIntegral (50 + (row + 1) * 25)) blocks
        
        -- Разные цвета для разных рядов
        case row of
          0 -> Cairo.setSourceRGB 1 0 0    -- Красный
          1 -> Cairo.setSourceRGB 1 0.5 0  -- Оранжевый
          2 -> Cairo.setSourceRGB 1 1 0    -- Желтый
          3 -> Cairo.setSourceRGB 0 1 0    -- Зеленый
          4 -> Cairo.setSourceRGB 0 0 1    -- Синий
          _ -> Cairo.setSourceRGB 1 1 1    -- Белый (запасной)
        
        mapM_ (\(x, y) -> do
          Cairo.rectangle x y blockWidth blockHeight
          Cairo.fill) rowBlocks
  
  -- Функция для обновления интерфейса
  let updateUI = do
        state <- readIORef gameStateRef
        Gtk.set infoLabel [Gtk.labelLabel := pack ("Счет: " ++ show (score state) ++ " | Жизни: " ++ show (lives state))]
        
        let statusMsg
              | gameOver state && null (blocks state) = "Поздравляем! Вы выиграли! Нажмите 'Новая игра'"
              | gameOver state = "Игра окончена! Нажмите 'Новая игра'"
              | gamePaused state = "Игра на паузе. Нажмите P для продолжения"
              | otherwise = "Игра идет... Управление: стрелки влево/вправо, P - пауза"
        
        Gtk.set statusLabel [Gtk.labelLabel := pack statusMsg]
        Gtk.widgetQueueDraw drawingArea
  
  -- Обработка нажатий клавиш
  Gtk.on window Gtk.keyPressEvent $ do
    keyVal <- Gtk.eventKeyVal
    state <- liftIO $ readIORef gameStateRef
    
    case keyVal of
      65361 -> do -- Стрелка влево
        liftIO $ do
          modifyIORef gameStateRef (\s -> movePaddle s (-paddleSpeed))
          updateUI
        return True
      
      65363 -> do -- Стрелка вправо
        liftIO $ do
          modifyIORef gameStateRef (\s -> movePaddle s paddleSpeed)
          updateUI
        return True
      
      112 -> do -- Клавиша 'P' (пауза)
        liftIO $ do
          modifyIORef gameStateRef (\s -> s { gamePaused = not (gamePaused s) })
          updateUI
        return True
      
      32 -> do -- Пробел (запуск мяча)
        liftIO $ do
          modifyIORef gameStateRef (\s -> 
            if gamePaused s && not (gameOver s)
            then s { gamePaused = False }
            else s)
          updateUI
        return True
      
      _ -> return False
  
  -- Обработка кнопки перезапуска
  Gtk.on restartButton Gtk.buttonActivated $ do
    newState <- initialGameState
    writeIORef gameStateRef newState
    updateUI
  
  -- Обработка кнопки паузы
  Gtk.on pauseButton Gtk.buttonActivated $ do
    modifyIORef gameStateRef (\s -> s { gamePaused = not (gamePaused s) })
    updateUI
  
  -- Игровой цикл (обновление каждые 20 мс)
  let gameLoop :: IO Bool
      gameLoop = do
        state <- readIORef gameStateRef
        newState <- updateGame state
        writeIORef gameStateRef newState
        updateUI
        return (not (gameOver newState))
  
  -- Запуск игрового цикла
  void $ Gtk.timeoutAdd gameLoop 20
  
  -- Обработка закрытия окна
  Gtk.on window Gtk.objectDestroy Gtk.mainQuit
  
  -- Отображение окна и запуск главного цикла
  Gtk.widgetShowAll window
  Gtk.mainGUI

-- Главная функция
main :: IO ()
main = do
  initialState <- initialGameState
  gameStateRef <- newIORef initialState
  createWindow gameStateRef